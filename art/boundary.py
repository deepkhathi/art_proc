# pipeline: RGB image -> thresholding -> boundary image(s)
import time
import warnings
from typing import List, Literal, Optional, Tuple

import cv2
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.figure import Figure
from scipy import ndimage, stats
from skimage.feature import peak_local_max
from skimage.filters.thresholding import threshold_multiotsu
from skimage.segmentation import find_boundaries, watershed

from .utils import display_image, init_logger


class BoundaryImage():
    r"""Generate boundary image by providing workhorse pipeline.

    Steps are:
    1. Convert RGB to grayscale
    2. Perform Otsu-based thresholding
    3. Calculate watershed image and create connected boundary image

    Parameters
    ----------
    rgb_image : numpy.ndarray, shape=(N, M, 3)
        If image has shape=(N, M), assume that this is already in grayscale
    verbose : bool, default=False
        Generate plots for each step

    Attributes
    ----------
    rgb_image : numpy.ndarray, shape=(N, M, 3)
        RGB image
    gray_image : numpy.ndarray, shape=(N, M)
        Grayscale image generated from input image
    threshold_image : numpy.ndarray, shape=(N, M)
        Retained threshold image generated by `BoundaryImage.threshold(...)`
    logger : logging.Logger
    verbose : bool, default=False
    """

    def __init__(
        self,
        rgb_image: np.ndarray,
        verbose: bool = False
    ):
        self.rgb_image = rgb_image
        self._orig_gray = False
        if len(self.rgb_image.shape) == 3:
            # check that there are only three channels
            if self.rgb_image.shape[-1] != 3:
                raise ValueError(
                    f"Number of channels ({self.rgb_image.shape[-1]}) != 3")
            self.gray_image: np.ndarray = cv2.cvtColor(
                self.rgb_image, cv2.COLOR_RGB2GRAY)
        elif len(self.rgb_image.shape) == 2:
            self.gray_image = self.rgb_image.copy()
            self._orig_gray = True
        else:
            raise ValueError(
                f"Dimensions of rgb_image must be (N, M, 3) "
                f"or (N, M); not {self.rgb_image.shape}")
        self.logger = init_logger("BoundaryImage")
        self.verbose = verbose

    def _return_image(self, image: np.ndarray, return_flag: bool):
        return image if return_flag else None

    def threshold(
        self,
        n_classes: int,
        return_image: bool = False
    ) -> Tuple[Optional[np.ndarray], Optional[Figure]]:
        r"""Perform Otsu thresholding

        Parameters
        ----------
        n_classes : int
            Minimum number of classes = 2 (for binary)
        return_image : bool, default=True
            Return thresholded image

        Returns
        -------
        threshold_image : numpy.ndarray, optional
            Return if `return_image = True`
        fig : matplotlib.figure.Figure, optional
            Only generated and returned if `self.verbose = True`

        Raises
        ------
        ValueError
            n_classes must be >= 2
        """
        if n_classes < 2:
            raise ValueError(f"n_classes ({n_classes}) must be >= 2")
        thresholds = threshold_multiotsu(self.gray_image, classes=n_classes)
        self.threshold_image: np.ndarray = np.digitize(
            self.gray_image, bins=thresholds)
        fig: Figure = None
        if self.verbose:
            fig, (ax0, ax1, ax2) = plt.subplots(ncols=3, figsize=(10, 5))
            display_image(self.rgb_image, cmap=self._orig_gray, ax=ax0)
            display_image(self.gray_image, cmap=True, ax=ax1)
            display_image(self.threshold_image, cmap=True, ax=ax2)
        self.logger.info(
            f"Completed Otsu thresholding with n_classes = {n_classes}")
        return (self._return_image(self.threshold_image, return_image), fig)

    def generate_boundary_image(
        self,
        use_bkg: bool = False,
        boundary_mode: Literal["thick", "inner",
                               "outer", "subpixel"] = "inner",
    ) -> Tuple[np.ndarray, Optional[Figure]]:
        r"""Perform watershed segmentation and calculate boundary image via
        connected component boundary search

        Parameters
        ----------
        use_bkg: bool, default=False
            Include inverted background for finding outer edges. May be helpful
            in low fidelity images
        boundary_mode : {"thick", "inner", "outer", "subpixel"}, default="inner"
            Boundary mode for `skimage.segmentation.find_boundaries`

        Returns
        -------
        boundary_image : numpy.ndarray, shape=(N, M)
            Binarized boundary image
        """
        uregs = np.unique(self.threshold_image.ravel())
        if not use_bkg:
            uregs = uregs[:-1]  # assume it is always last
            self.logger.info(
                "Dropping putative background region for boundary calculations")
        b_list: List[np.ndarray] = [None] * len(uregs)
        self.logger.info(
            f"Starting boundary process for all {len(uregs)} regions")
        top_start = time.time()
        for k in uregs:
            step_start = time.time()
            self.logger.info(
                f"Starting boundary calculation for region {k + 1} out of {len(uregs)}")
            thresh_region = np.zeros_like(self.threshold_image, dtype="uint8")
            thresh_region[self.threshold_image == k] = 1
            # watershed (Euclidean distance transform, peaks, watershed labels)
            distance_map = ndimage.distance_transform_edt(thresh_region)
            with warnings.catch_warnings():
                pl_start = time.time()
                warnings.simplefilter("ignore", FutureWarning)
                local_max_map = peak_local_max(
                    distance_map, min_distance=1,
                    indices=None, labels=thresh_region)
                self.logger.info(
                    f"Completed Local peak mapping on distance image in "
                    f"{time.time() - pl_start:.1f} seconds")
            markers = ndimage.label(local_max_map)[0]
            labels = watershed(-distance_map, markers=markers,
                               mask=thresh_region)
            # drop mode label (remove erroneous excess lines from transform)
            label_copy = labels.copy()
            mode = stats.mode(labels.ravel(), keepdims=None)[0]
            label_copy[labels != mode] = 1
            label_copy[labels == mode] = 0
            # get boundary
            b_list[k] = find_boundaries(label_copy, mode=boundary_mode)
            self.logger.info(
                f"Completed boundary calculation for region {k + 1} in "
                f"{time.time() - step_start:.0f} seconds")
        boundary_image = np.apply_along_axis(
            np.any, axis=2, arr=np.array(b_list).transpose([1, 2, 0]))
        self.logger.info(
            f"Completed all boundary generation in "
            f"{(time.time() - top_start) / 60:.2f} minutes")
        fig: Figure = None
        if self.verbose:
            fig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(8, 6))
            display_image(self.rgb_image, cmap=self._orig_gray, ax=ax0)
            display_image(~boundary_image, cmap="gray", ax=ax1)
        return (boundary_image, fig)
